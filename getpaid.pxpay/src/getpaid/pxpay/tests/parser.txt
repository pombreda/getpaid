The parser is responsible for parsing and validating the XML data
received or created for pxpay transactions. It uses internal models
against which it tests the data.

For documentation on the XML packets in the pxpay transaction see
http://www.dps.co.nz/technical_resources/ecommerce_hosted/pxpay.html

    >>> from getpaid.pxpay import parser
    >>> from getpaid.pxpay.config import *

    >>> from zope.component import getAdapter
    >>> from pprint import pprint

    Some fake data to use

    >>> data = {
    ...     'PxPayServerType':TEST_SERVER_TYPE,
    ...     'PxPayUserId':'testid',
    ...     'PxPayKey':'testkey',
    ...     'PxPaySiteCurrency':u"NZD",
    ...     'order_id':'test_order_1',
    ...     'total_price':321.00,
    ...     }

Initial Request
---------------

The first part of the pxpay process is to send an initial request.
This contains data about the pxpay account being used and the details
of the payment to be made.

    >>> initial_request = parser.InitialRequest()

    The internal model looks like:

    >>> print initial_request.modeltext
    <BLANKLINE>
    <GenerateRequest required="required" maxdata="0">
        <PxPayUserId datatype="str" maxdata="32" required="required" />
        <PxPayKey datatype="str" maxdata="64" required="required" />
        <AmountInput datatype="float" maxdata="13" maxval="99999.99" required="required" />
        <BillingId datatype="str" maxdata="32" />
        <CurrencyInput datatype="str" maxdata="4" datavalues="CAD CHF EUR FRF GBP HKD JPY NZD SGD USD ZAR AUD WST VUV TOP SBD PNG MYR KWD FJD" required="required" />
        <DpsBillingId datatype="str" maxdata="16" />
        <DpsTxnRef datatype="str" maxdata="16" />
        <EmailAddress datatype="str" maxdata="255" />
        <EnableAddBillCard datatype="int" datavalues="0 1" maxdata="1" />
        <MerchantReference datatype="str" maxdata="64" required="required" />
        <TxnData1 datatype="str" maxdata="255" />
        <TxnData2 datatype="str" maxdata="255" />
        <TxnData3 datatype="str" maxdata="255" />
        <TxnType datatype="str" datavalues="Auth Complete Purchase" />
        <TxnId datatype="str" maxdata="16" />
        <UrlFail datatype="str" maxdata="255" required="required" />
        <UrlSuccess datatype="str" maxdata="255" required="required" />
    </GenerateRequest>
    <BLANKLINE>

    Set up the actual request model ... this is termed a "state"

    >>> initial_request.setRoot('GenerateRequest')
    >>> initial_request.addNode('/', 'PxPayUserId',
    ...                         node_data=data['PxPayUserId'])
    <Element PxPayUserId at ...>
    >>> initial_request.addNode('/', 'PxPayKey',
    ...                         node_data=data['PxPayKey'])
    <Element PxPayKey at ...>
    >>> initial_request.addNode('/', 'AmountInput',
    ...                         node_data=data['total_price'])
    <Element AmountInput at ...>
    >>> initial_request.addNode('/', 'CurrencyInput',
    ...                         node_data=data['PxPaySiteCurrency'])
    <Element CurrencyInput at ...>
    >>> initial_request.addNode('/', 'MerchantReference',
    ...                         node_data="Test Transaction")
    <Element MerchantReference at ...>
    >>> initial_request.addNode('/', 'TxnType',
    ...                         node_data="Purchase")
    <Element TxnType at ...>
    >>> initial_request.addNode('/', 'TxnId',
    ...                         node_data='tr_1234')
    <Element TxnId at ...>
    >>> initial_request.addNode('/', 'UrlFail',
    ...                         node_data='/@@getpaid-checkout-wizard')
    <Element UrlFail at ...>
    >>> initial_request.addNode('/', 'UrlSuccess',
    ...                         node_data='/@@getpaid-checkout-wizard')
    <Element UrlSuccess at ...>

    >>> print initial_request.generateXML()
    <GenerateRequest><PxPayUserId>testid</PxPayUserId><PxPayKey>testkey</PxPayKey><AmountInput>321.0</AmountInput><CurrencyInput>NZD</CurrencyInput><MerchantReference>Test Transaction</MerchantReference><TxnType>Purchase</TxnType><TxnId>tr_1234</TxnId><UrlFail>/@@getpaid-checkout-wizard</UrlFail><UrlSuccess>/@@getpaid-checkout-wizard</UrlSuccess></GenerateRequest>

    We can validate that this conforms to the model

    >>> state_valid, errors = initial_request.state_validate()
    >>> state_valid
    True
    >>> errors
    []

    Lets demonstrate an error

    >>> initial_request.delNode('/', 'CurrencyInput')

    >>> _ = initial_request.addNode('/', 'CurrencyInput',
    ...                             node_data='NotACurrency')

    >>> '<CurrencyInput>NotACurrency</CurrencyInput>' in initial_request.generateXML()
    True

    >>> state_valid, errors = initial_request.state_validate()
    >>> state_valid
    False
    >>> pprint(errors)
    [{'datavalues': "Element tag 'CurrencyInput' requires its data to be only one of '['CAD', 'CHF', 'EUR', 'FRF', 'GBP', 'HKD', 'JPY', 'NZD', 'SGD', 'USD', 'ZAR', 'AUD', 'WST', 'VUV', 'TOP', 'SBD', 'PNG', 'MYR', 'KWD', 'FJD']'",
      'maxdata': "Element tag 'CurrencyInput' has too much data: 12, when the maximum allowed is: 4)"}]


    Lets test a completely broken request

    >>> initial_request = parser.InitialRequest()
    >>> initial_request.setRoot('GenerateRequest')
    >>> _ = initial_request.addNode('/', 'PxPayUserId',
    ...                             node_data='this can be anything')
    >>> _ = initial_request.addNode('/', 'PxPayKey',
    ...                             node_data='this can be anything')
    >>> _ = initial_request.addNode('/', 'AmountInput',
    ...                             node_data='not a number')
    >>> _ = initial_request.addNode('/', 'CurrencyInput',
    ...                             node_data='not a currency')
    >>> _ = initial_request.addNode('/', 'MerchantReference',
    ...                             node_data="Test Transaction")
    >>> _ = initial_request.addNode('/', 'TxnType',
    ...                             node_data="Not a TxnType")
    >>> _ = initial_request.addNode('/', 'TxnId',
    ...                             node_data='this can be anything')
    >>> _ = initial_request.addNode('/', 'UrlFail',
    ...                             node_data='not-a-url')
    >>> _ = initial_request.addNode('/', 'UrlSuccess',
    ...                             node_data='not-a-url')

    We can validate that this conforms to the model

    >>> state_valid, errors = initial_request.state_validate()
    >>> state_valid
    False
    >>> pprint(errors)
    [{'datatype': "Element tag 'AmountInput' requires its data to be a float"},
     {'datavalues': "Element tag 'CurrencyInput' requires its data to be only one of '['CAD', 'CHF', 'EUR', 'FRF', 'GBP', 'HKD', 'JPY', 'NZD', 'SGD', 'USD', 'ZAR', 'AUD', 'WST', 'VUV', 'TOP', 'SBD', 'PNG', 'MYR', 'KWD', 'FJD']'",
      'maxdata': "Element tag 'CurrencyInput' has too much data: 14, when the maximum allowed is: 4)"},
     {'datavalues': "Element tag 'TxnType' requires its data to be only one of '['Auth', 'Complete', 'Purchase']'"},
     {'maxdata': "Element tag 'TxnId' has too much data: 20, when the maximum allowed is: 16)"}]


Initial Response
----------------

When the pxpay processor receives an Intial Request it responds with
some xml that points us to a URL that we need to redirect the user to
so they can enter their payment details. This is termed "Request" data
by pxpay.

    >>> data = """<Request valid="1"><URI>https://www.paymentexpress.com/pxpay/pxpay.aspx?userid=TestAccount&amp;request=e88cd9f2f6f301c712ae2106ab2b6137d86e954d2163d1042f73cce130b2c 88c06daaa226629644dc741b16deb77ca14ce4c59db84929eb0280837b92bd2ffec 2fae0b9173c066dab48a0b6d2c0f1006d4d26a8c75269196cc540451030958d257c1 86f587ad92cfa7472b101ef72e45cda3bf905862c2bf58fc214870292d6646f7c4ad 02a75e42fc64839fc50cea8c17f65c6a9b83b9c124e2f20844b63538e13a8cff17ec d8f165aee525632fd3661b591626f5fb77725ade21648fed94553f43bfa69acf3557 0ff8fdcbaf8a13a3fa7deb244017e41749e652a3549a5dbe20c6c3a7a66aa5901e3f 87150f7fc</URI></Request>"""

    >>> initial_response = parser.InitialResponse(data)
    >>> state_valid, errors = initial_response.state_validate()
    >>> state_valid
    True
    >>> pprint(errors)
    []

    Make sure a broken response doesn't validate

    >>> data = """<Request><URI>https://www.paymentexpress.com/pxpay/pxpay.aspx?userid=TestAccount&amp;request=e88cd9f2f6f301c712ae2106ab2b6137d86e954d2163d1042f73cce130b2c 88c06daaa226629644dc741b16deb77ca14ce4c59db84929eb0280837b92bd2ffec 2fae0b9173c066dab48a0b6d2c0f1006d4d26a8c75269196cc540451030958d257c1 86f587ad92cfa7472b101ef72e45cda3bf905862c2bf58fc214870292d6646f7c4ad 02a75e42fc64839fc50cea8c17f65c6a9b83b9c124e2f20844b63538e13a8cff17ec d8f165aee525632fd3661b591626f5fb77725ade21648fed94553f43bfa69acf3557 0ff8fdcbaf8a13a3fa7deb244017e41749e652a3549a5dbe20c6c3a7a66aa5901e3f 87150f7fc</URI></Request>"""

    >>> initial_response = parser.InitialResponse(data)
    >>> state_valid, errors = initial_response.state_validate()
    >>> state_valid
    False
    >>> pprint(errors)
    [{'attributes': ["Element tag 'Request' requires an attribute named 'valid' with a value of only one of '['0', '1']'"]}]

    >>> data = """<empty></empty>"""
    >>> initial_response = parser.InitialResponse(data)
    >>> state_valid, errors = initial_response.state_validate()
    >>> state_valid
    False
    >>> pprint(errors)
    [{'attributes': ["Element tag 'empty' requires an attribute named 'valid' with a value of only one of '['0', '1']'"],
      'required': ["Element tag 'empty' requires a child with tag 'URI'"],
      'tag': "Element tag 'empty' does not match model tag 'Request'"}]


    Empty data raises an exception

    >>> data = ""
    >>> initial_response = parser.InitialResponse(data)
    Traceback (most recent call last):
    ...
    ExpatError: no element found: line 1, column 0

